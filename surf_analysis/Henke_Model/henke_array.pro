pro henke_array,compound_name,density,energies,f1,f2,delta,beta, $	graze_mrad,reflect,help=help;+; pro henke_array,compound_name,density,energies,f1,f2,delta,beta, $;	graze_mrad,reflect;; All you give it is compound_name and density;; CJJ Feb. 93;;	Updated so will read *.DAT file on Intel-based Mac;-if (keyword_set(help) or (n_elements(compound_name) eq 0)) then begin  print,'henke_array,compound_name,density,energies,f1,f2,delta,beta, $'  print,'    graze_mrad,reflect'  print,'  To get 1/e absorption length "mu" in microns, do:'  print,'    mu=1.2398/(energies*4.*!pi*beta)'  returnendifcompound,compound_name,density,atwt,z_arraybackslash='\';if (!version.os eq 'windows') then begin;	system_henkedat_file='c:'+backslash+'henke'+backslash+'henke.dat';endif else if (!version.os eq 'AIX') then begin;	system_henkedat_file='/usr/local/lib/xraycode/henke/henke.dat';endif else if (!version.os eq 'vms') then begin;	system_henkedat_file='public_disk:[x1_lib.henke]henke.dat';endif else if (!version.os eq 'sunos') then begin;	system_henkedat_file='$rocket/henke/henke.dat';endif else if (!version.os eq 'MacOS') then begin;	system_henkedat_file='henke.dat';endif else if (!version.os eq 'darwin') then begin	sdir = getenv('henke_model')	if (strlen(sdir) gt 0) then sdir = sdir+'/'	system_henkedat_file=sdir+'henke.dat';endif else begin;	message,'Unknown system!';	return;endelseon_ioerror,try_system_fileopenr,lun,'henke.dat',/get_lungoto,got_filetry_system_file: on_ioerror,no_fileopenr,lun,system_henkedat_file,/get_lungoto,got_fileno_file: message,'Could not open file "henke.dat" or "'+ $	system_henkedat_file+'".'close,lunfree_lun,lunreturngot_file: on_ioerror,confusednum_energies=long(0)num_elements=long(0)readu,lun,num_energies,num_elementsswap_endian_inplace, num_energies, /swap_if_little_endianswap_endian_inplace, num_elements, /swap_if_little_endianenergies=fltarr(num_energies)readu,lun,energiesswap_endian_inplace, energies, /swap_if_little_endianf1=fltarr(num_energies)f2=fltarr(num_energies)this_f1=fltarr(num_energies)this_f2=fltarr(num_energies); at start was num_elements, num_energies, energy_array)header_offset=4*(2+num_energies)maxz=n_elements(z_array)for i=0,(maxz-1) do begin    if (z_array(i) gt 0.) then begin	; 2 for f1, f2, 4 for 4 byte float	offset=header_offset+i*2*num_energies*4	point_lun,lun,offset	readu,lun,this_f1	readu,lun,this_f2	swap_endian_inplace, this_f1, /swap_if_little_endian	swap_endian_inplace, this_f2, /swap_if_little_endian	f1=f1+z_array(i)*this_f1	f2=f2+z_array(i)*this_f2    endifendforAVOGADRO=6.02204531e23HC=12398.54RE=2.817938070e-13 ; in cmif (atwt ne 0.0) then begin	molecules_per_cc = density * AVOGADRO / atwtendif else begin	molecules_per_cc = 0.0;endelsewavelength=HC/energies; This constant has wavelength in angstroms and then; they are converted to centimeters.constant = RE * (1.0e-16 * wavelength * wavelength) * $		molecules_per_cc / (2.0 * !pi)delta = constant * f1;beta = constant * f2;if (n_elements(graze_mrad) eq 0) then begin	graze_mrad=0.endifif (graze_mrad eq 0.) then begin	reflect=1.+fltarr(num_energies)endif else begin	theta = 1.0e-3 * graze_mrad	sinth = sin(theta)	sinth2 = sinth * sinth	coscot = cos(theta)	coscot = coscot * coscot / sinth	alpha = 2.0 * delta - delta * delta + beta * beta	gamma = 2.0 * (1.0 - delta) * beta	rhosq = 0.5 * (sinth2 - alpha + $		sqrt((sinth2 - alpha)*(sinth2-alpha) + gamma*gamma) )	rho = sqrt(rhosq)	i_sigma = (4.0 * rhosq * (sinth - rho) * (sinth - rho) + $			gamma * gamma) / $		(4.0 * rhosq * (sinth + rho) * (sinth + rho) + $			gamma * gamma)	piosig = (4.0 * rhosq * (rho - coscot) * (rho - coscot) + $			gamma * gamma) / $		(4.0 * rhosq * (rho + coscot) * (rho + coscot) + $			gamma * gamma)	reflect= 50.0 * i_sigma * (1 + piosig)endelseclose,lunfree_lun,lunreturnconfused:message,'got confused'close,lunfree_lun,lunreturnend