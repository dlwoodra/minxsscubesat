;+; NAME:;	megs_calc_irr;; PURPOSE:;	Convert MEGS image into irradiance units;; CALLING SEQUENCE:  ;	data = megs_calc_irr( image, channel, [ integtime=integtime, /debug, /reference ] );; INPUTS:;	image = MEGS 2048 x 1024 image;	channel = 'A' or 'B';   integtime = optional input for integration time (default is 10 sec);	/debug = option to print debug messages;	/reference = option to overplot reference spectrum (Woods & Rottman, 2002) - SC Min;; OUTPUTS:  ;	data = structured array of irradiance, wavelength, etc. OR -1 if error ;; COMMON BLOCKS:;	MEGS_Dark_Block;   MEGS_Sens_Block;; PROCEDURE:;	1.  Check parameters;	2.  Read Dark if not in common block;	3.  Read Sensitivity if not in common block;   4.  Get wavelength and bandpass;	5.  Get aperture area and gain;	6.  Calculate irradiance;			irr = compress2spectrum(image-dark) * gain / integtime / area / sensitivity / bandpass;	7.  Plot the result and return data;; MODIFICATION HISTORY:;	10/20/06		Tom Woods		Original draft of code as quick-look conversion;;+function  megs_calc_irr, image, channel, integtime=integtime, debug=debug, reference=referencecommon MEGS_Dark_Block, adark, bdarkcommon MEGS_Sens_Block, a1sens, a2sens, bsens;;	1.  Check parameters;debugmsg = 0if (keyword_set(debug)) then debugmsg = 1if (n_params() lt 2) then begin  channel = ''  print, 'USAGE: data = megs_calc_irr( image, channel, [ integtime=integtime, /debug, /reference] )'  channel = ''  return, -1Lendifch1 = strupcase(strmid(channel,0,1))if (ch1 ne 'A') and (ch1 ne 'B') then begin  print, 'WARNING: invalid channel letter of ', ch1, ' - assuming "B" channel'  ch1 = 'B'endifif not keyword_set(integtime) then integtime = 10.if (strupcase(!d.name) eq 'WIN') then dslash='\' else dslash='/';;	energy factor - to convert from photons / sec / cm^2 / nm  TO  mW / m^2 / nm;		(1E4 cm^2 / m^2) * (1E3 mW / W) * (h * c / wave)  * (1E9 nm / m);			- BUT leave out "wave";efactor = 1.D4 * 1.D3 * 6.1261D-34 * 2.9979D8 * 1.D9if keyword_set(reference) then begin  mdir = getenv( 'solar_models' )  if (strlen(mdir) gt 0) then mdir = mdir + dslash  reffile = mdir + 'ref_min_27day_11yr.dat'  print, 'Reading Reference Spectrum from ', reffile  ref = read_dat( reffile )  ref[1,*] = ref[1,*] * efactor / ref[0,*]	; convert ph/s/cm^2/nm to mW/m^2/nmendif;;	2.  Read Dark if not in common block;if (n_elements(adark) lt 2) or (n_elements(bdark) lt 2) then begin  caldir = getenv( 'eve_cal' )  if strlen(caldir) gt 1 then caldir = caldir + dslash  darkfile = 'dark'+dslash+'megs_rkt_adark_bdark.sav'  print, 'Restoring Dark Data from ', darkfile  restore, caldir + darkfile		; adark & bdark restored  endif;;	3.  Read Sensitivity if not in common block;a1size = size(a1sens)a2size = size(a2sens)bsize = size(bsens)if (a1size[0] lt 1) or (a2size[0] lt 1) or (bsize[0] lt 1) then begin  caldir = getenv( 'eve_cal' )  if strlen(caldir) gt 1 then caldir = caldir + dslash  sensfile = 'sensitivity'+dslash+'megs_rkt_sens_sep06.sav'  print, 'Restoring Sensitivity Data from ', sensfile  restore, caldir + sensfile		; a1sens & a2sens & bsens restored    ;  xsens.wave and xsens.qt for each variableendif;;   4.  Get wavelength (nm) and bandpass (nm);		wavelength is given in Xsens stored in common block;if (ch1 eq 'A') then begin  wave = a1sens.wave    ; which is same as a2sens.waveendif else begin  wave = bsens.waveendelsenwave = n_elements(wave)bandpass = abs(shift(wave,-1) - shift(wave,1))/2.bandpass[0] = bandpass[1]bandpass[nwave-1] = bandpass[nwave-2];;	5.  Get aperture area (cm^2) and gain (unitless);		Note that megs_area.pro is located in $eve_cal/code/SURF_lib/;if (ch1 eq 'A') then begin  area1 = megs_area( 'A1' )  area2 = megs_area( 'A2' )endif else begin  area = megs_area( 'B' )endelsegain = 2.		; default 2 electrons / DN assumed for all CCDs (quick look only & used for SURF QT);;	6.  Calculate irradiance;			irr = compress2spectrum(image-dark) * gain / integtime / area / sensitivity / bandpass;;	make output data structure;		wave in nm;		flux in mW / m^2 / nm;		cnt in DN (raw data);		integ_time in seconds;		area in cm^2;if (ch1 eq 'A') then begin  data = { wave: fltarr(2048), flux1: fltarr(2048), flux2: fltarr(2048), $  		cnt1: fltarr(2048), cnt2: fltarr(2048), integ_time: 0.0, area1: 0.0, area2: 0.0 }  data.wave = wave  data.integ_time = integtime  data.area1 = area1  data.area2 = area2  dimage = image - adark  for j=0,2047 do data.cnt1[j] = total(dimage[j,0:511])  data.flux1 = (data.cnt1 * gain) / (integtime * area1 * bandpass * a1sens.qt)  data.flux1 = data.flux1 * efactor / wave  ; convert ph/sec/cm^2/nm to mW/m^2/nm  for j=0,2047 do data.cnt2[j] = total(dimage[j,512:1023])  data.flux2 = (data.cnt2 * gain) / (integtime * area2 * bandpass * a2sens.qt)  data.flux2 = data.flux2 * efactor / wave  ; convert ph/sec/cm^2/nm to mW/m^2/nm  pflux1 = data.flux1  pflux2 = data.flux2endif else begin  data = { wave: fltarr(2048), flux: fltarr(2048), cnt: fltarr(2048), integ_time: 0.0, area: 0.0 }  data.wave = wave  data.integ_time = integtime  data.area = area  dimage = image - bdark  for j=0,2047 do data.cnt[j] = total(dimage[j,*])  data.flux = (data.cnt * gain) / (integtime * area * bandpass * bsens.qt)  data.flux = data.flux * efactor / wave  ; convert ph/sec/cm^2/nm to mW/m^2/nm  pflux1 = data.flux  pflux2 = 0endelse;;	7.  Plot the result and return data;setplotcc = rainbow( 7 )mtitle = 'MEGS-' + ch1ytitle = 'Irradiance (mW/m!U2!N/nm)'xtitle = 'Wavelength (nm)'yrange = [min(abs(pflux1)) > 1E-3,max(pflux1)*1.1]if (yrange[0] gt 1E-2) then yrange[0] = 1E-2if (yrange[1] gt 1E5) then yrange[1] = 1E5plot_io, wave, pflux1, yrange=yrange, ystyle=1, xstyle=1, $  xtitle=xtitle, ytitle=ytitle, title=mtitleoplot, wave, pflux1, color=cc[5]if (n_elements(pflux2) eq n_elements(wave)) then oplot, wave, pflux2, color=cc[3]if keyword_set(ref) then begin  oplot, ref[0,*], ref[1,*], psym=10, color=cc[0]endifif (debugmsg ne 0) then stop, 'Check out results at end of megs_calc_irr() ...'return, dataend